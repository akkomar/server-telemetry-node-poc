package glean

// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// AUTOGENERATED BY glean_parser v7.2.2.dev8+g91d4c811. DO NOT EDIT.

// required imports
import (
    "fmt"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

// log type string used to identify logs to process in the Moz Data Pipeline
var gleanEventMozlogType string = "glean-server-event"


// TODO: confirm envelope schema and assemble this json in a nicer way
// TODO: decide how to log - stdout, mozlog, etc, is there a standard way for new go services in gcpv2?
func logEvent(eventType string, message string) {
	fmt.Printf("{\"Type\": \"%s\", \"Fields\": %s\n", eventType, message)
}


type GleanEventsLogger struct {
	AppID             string
	AppDisplayVersion string
	AppChannel        string
}

// exported type for public method parameters
type RequestInfo struct {
	UserAgent string
	IpAddress string
}

// deafult empty values will be omitted in json from ping struct definition
var defaultRequestInfo = RequestInfo{
	UserAgent: "",
	IpAddress: "",
}

// structs to construct the glean ping
type clientInfo struct {
	TelemetrySDKBuild string `json:"telemetry_sdk_build"`
	FirstRunDate      string `json:"first_run_date"`
	OS                string `json:"os"`
	OSVersion         string `json:"os_version"`
	Architecture      string `json:"architecture"`
	AppBuild          string `json:"app_build"`
	AppDisplayVersion string `json:"app_display_version"`
	AppChannel        string `json:"app_channel"`
}

type pingInfo struct {
	Seq       int    `json:"seq"`
	StartTime string `json:"start_time"`
	EndTime   string `json:"end_time"`
}

type ping struct {
	DocumentNamespace string `json:"document_namespace"`
	DocumentType      string `json:"document_type"`
	DocumentVersion   string `json:"document_version"`
	DocumentID        string `json:"document_id"`
	UserAgent         string `json:"user_agent,omitempty"`
	IpAddress         string `json:"ip_address,omitempty"`
	Payload           string `json:"payload"`
}

type metrics map[string]map[string]interface{}

type pingPayload struct {
	ClientInfo clientInfo   `json:"client_info"`
	PingInfo   pingInfo     `json:"ping_info"`
	Metrics    metrics      `json:"metrics"`
	Events     []gleanEvent `json:"events"`
}

type gleanEvent struct {
	Category  string          `json:"category"`
	Name      string          `json:"name"`
	Timestamp int64           `json:"timestamp"`
	Extra     [][]interface{} `json:"extra"`
}

func (g GleanEventsLogger) createClientInfo() clientInfo {
	// Fields with default values are required in the Glean schema, but not used in server context
	return clientInfo{
		TelemetrySDKBuild: "glean_parser v7.2.2.dev8+g91d4c811",
		FirstRunDate:      "Unknown",
		OS:                "Unknown",
		OSVersion:         "Unknown",
		Architecture:      "Unknown",
		AppBuild:          "Unknown",
		AppDisplayVersion: g.AppDisplayVersion,
		AppChannel:        g.AppChannel,
	}
}

func createPingInfo() pingInfo {
	var now = time.Now().UTC().Format("2006-01-02T15:04:05.000Z")
	return pingInfo{
		Seq:       0,
		StartTime: now,
		EndTime:   now,
	}
}

func (g GleanEventsLogger) createPing(documentType string, config RequestInfo, payload string) ping {
	var documentId = uuid.New()
	return ping{
		DocumentNamespace: g.AppID,
		DocumentType:      documentType,
		DocumentVersion:   "1",
		DocumentID:        documentId.String(),
		UserAgent:         config.UserAgent,
		IpAddress:         config.IpAddress,
		Payload:           string(payload),
	}
}

// method called by each event method
func (g GleanEventsLogger) record(
	documentType string,
	requestInfo RequestInfo,
	metrics metrics,
	events []gleanEvent,
) {
	var telemetryPayload = pingPayload{
		ClientInfo: g.createClientInfo(),
		PingInfo:   createPingInfo(),
		Metrics:    metrics,
		Events:     events,
	}

	var payloadJson, payloadErr = json.Marshal(telemetryPayload)
	if payloadErr != nil {
		panic("Unable to marshal payload to json")
	}

	// TODO: confirm expected shape with data team
	// ruby implementation wraps ping in another js object before JSON.dumping to a string
	// ex. { "Timestamp": string, "Logger": name, "Type": gleanEventMozLogType, "Severity": string, "Pid": string, "Fields": pingJson }
	// js appears not to
	var ping = g.createPing(documentType, requestInfo, string(payloadJson))
	var pingJson, err = json.Marshal(ping)
	if err != nil {
		panic("Unable to marshal ping to json")
	}
	logEvent(gleanEventMozlogType, string(pingJson))
}

type EventBackendObjectUpdate struct {
  IdentifiersFxaAccountId string // The user's FxA account ID, if available.
  ObjectType string // A simple name to describe the object whose state changed. For example, `api_request`.
  ObjectState string // A JSON representation of the latest state of the object.
}

// Record and submit an EventBackendObjectUpdate event.
// Event triggered by the backend to record the change in state of an object (e.g. API requests to the mozilla.social Mastodon server). In the future, we could potentially use this event to track changes in state to core Mastodon objects (e.g. accounts and posts).
func (g GleanEventsLogger) RecordEventBackendObjectUpdate(
	requestInfo RequestInfo,
	params EventBackendObjectUpdate,
) {
	var metrics = metrics{
    "string": {
      "identifiers.fxa_account_id": params.IdentifiersFxaAccountId,
    },
	}
	var extraKeys = [][]interface{}{
    {"object_type", params.ObjectType},
    {"object_state", params.ObjectState},
	}
	var events = []gleanEvent{
		gleanEvent{
			Category:  "backend",
			Name:      "object_update",
			Timestamp: time.Now().UnixMilli(),
			Extra:     extraKeys,
		},
	}
	g.record("events", requestInfo, metrics, events)
}

// Record and submit an EventBackendObjectUpdate event omitting user request info
// Event triggered by the backend to record the change in state of an object (e.g. API requests to the mozilla.social Mastodon server). In the future, we could potentially use this event to track changes in state to core Mastodon objects (e.g. accounts and posts).
func (g GleanEventsLogger) RecordEventBackendObjectUpdateWithoutUserInfo(
  params EventBackendObjectUpdate,
) {
	g.RecordEventBackendObjectUpdate(defaultRequestInfo, params)
}

